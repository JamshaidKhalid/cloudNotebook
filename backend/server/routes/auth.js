const express = require('express');
const router = express.Router();
const Users = require('../model/Users');
const { body, validationResult } = require('express-validator');
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
const fetchUser = require('../middleware/fetchUser');

const jwt_secret = 'thisismysecretforjsonwebtoken';

/**
 Express validator is used to check the data before sending it to the database
 it is passed as 2nd argument to the post method as an array and the validation methods can be seen at documentaion
 */
//ROUTE1: creating a user        localhost/api/auth/signup,    NO AUTHENTICATION/LOGIN REQUIRED
router.post('/signup', [
    body('name').not().isEmpty().withMessage('Name is required').isLength({ min: 3 }),
    body('email').not().isEmpty().withMessage('Email is required').isEmail(),
    body('password').not().isEmpty().withMessage('Password is required').isLength({ min: 5 })
], async (req, res) => {

    /**
     before creating the user instance in to be send in database,
     the following lines will check the errors produced in the 2nd argument of the post method
     if the array is not empty i.e there are erros then it will send the errors in the response
     and nothing will be send to database
     */
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
        return res.status(422).json({ errors: errors.array() });
    }


    /*
     Checking if the user already exists. findOne() is Mongo's method which will return true if the user exists
    */


    try {
        if (await (Users.findOne({ email: req.body.email }))) {
            return res.status(422).json({ errors: [{ msg: 'User already exists' }] });
        }

        //encrypting and hashing the password and hashed password will be stored in database
        const salt = await bcrypt.genSalt(10);
        const hashedPassword = await bcrypt.hash(req.body.password, salt);

        //creating the user instance
        const user = await new Users({
            name: req.body.name,
            email: req.body.email,
            password: hashedPassword,
            date: req.body.date
        });

        //now we will not send user instance to response
        // res.send(user);

        //instead we will send a session/token/jwt token to the user
        const data = {
            id: user.id
        }

        //this token will be sent to the user and will be used to authenticate the user
        //jwt.sing() is taking userData which is in this case ID of user generated by mongoDB and a secret password
        const authToken = jwt.sign(data, jwt_secret);

        res.send({ authToken });

        user.save().catch(err => console.log(err));

    } catch (e) {
        console.log(e);
        res.status(500).send("Some error has occured");
    }




});


//ROUTE2: Logging in a user    localhost/api/auth/signin,    NO AUTHENTICATION/LOGIN REQUIRED
//so finally the following post method will be used to login the user
router.post('/signin', [
    body('email').not().isEmpty().withMessage('Email is required').isEmail(),
    body('password').not().isEmpty().withMessage('Password is required')
], async (req, res) => {

    /**
     before accessing the database to compare credentials,
     the following lines will check the errors produced in the 2nd argument of the post method
     if the array is not empty i.e there are erros then it will send the errors in the response
     and nothing will be send to database
     */
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
        return res.status(422).json({ errors: errors.array() });
    }

    //getting email and password from body entered by the user
    const { email, password } = req.body;


    try {
        //checking if the user exists in database or not
        let user = await Users.findOne({ email });
        if (!user) {
            return res.status(422).json({ errors: [{ msg: 'Invalid Credentials' }] });
        }

        // comparing the password entered by the user with the hashed password in database
        // bcrypt.compare() is a method which will return true if the password entered by the user is same as the hashed password in database
        if (!await bcrypt.compare(password, user.password)) {
            return res.status(422).json({ errors: [{ msg: 'Invalid Credentials' }] });
        }


        //finally if the user exists and the password is correct then we will send a session/token/jwt token to the user
        const data = {
            id: user.id
        }

        //this token will be sent to the user and will be used to authenticate the user
        //jwt.sign() is taking userData which is in this case ID of user generated by mongoDB and a secret password
        const authToken = jwt.sign(data, jwt_secret);

        res.send({ authToken });

    } catch (error) {
        console.log(error);
        res.status(500).send("Internal Server Error");

    }

});


//ROUTE 3: getting details of logged in user    localhost/api/auth/getuser,    AUTHENTICATION/LOGIN REQUIRED
/**
 Here fetchUser is a middleware which will be used to check if the user is logged in or not
 It will provide userID and then async function will be called
 */
router.post('/getuser', fetchUser, async (req, res) => {
    try {
        //req.id is provided by fetchuser and we are using req.user.id to get userID and then simple
        const userId = req.user.id;     
        const user = await Users.findById(userId).select('-password');
        res.send(user);
    } catch (error) {
        console.log(error);
        res.status(500).send("Internal Server Error");
    }

});


module.exports = router;